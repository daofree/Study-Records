背景：某段时间内，程序由 一/多 条执行路径
    
# 多线程概述
    ·看见的进程：任务管理器中正在运行的程序，是系统进行资源分配和调用的独立单位。
        每一个进程都有它自己的内存空间和系统资源。
    
    ·多进程意义？
        早期单进程计算机--dos系统--只能做一件事。
        一个时间段可以执行多个任务，提高CPU的使用率。
    ·一边玩游戏一边听音乐---同时？？
    否，因为单核CPU在某一点上只能做一件事。（双核开两个进程有可能，但进程数>>核数）
    事实上，一边一边是CPU在做程序间高效切换！超出了人类感知...
        
    ·看不见的线程：一个进程内可执行多个任务，每个任务就是一个线程。
        线程是程序的执行单元，执行路径，是程序使用CPU的最基本单位。
        进程中单个顺序控制流，是一条执行路径
        
        ·单线程程序：植物大战僵尸
        ·多线程程序：迅雷下载，计时扫雷
    
    ·多线程意义：不是提高执行速度，提高应用程序的使用率。
                程序的执行是抢CPU的资源（执行权）。
    
    ·并行与并发？？
        并行：逻辑上同时发生，某一时间段内同时运行多个程序。
        并发：物理上同时发生，某一时间点同时运行多个程序。
    
    ·Java运行原理？
        Java命令启动JVM，即相当于启动了一个应用程序，即进程，该进程会自动启动一个
        主线程，然后主线程会调用某个类的main方法。故main方法执行在主线程中。
    
    ·JVM启动时单线程还是多线程？多，gc不起，内存溢出！        
        
# 多线程实现--4种方式？
    前提：先调用系统功能创建一个进程，但Java不能直接调用系统功能。
        虽不能直接实现，但java可以调用C/C++写好的程序来实现。即
        由C/C++调用系统功能创建进程。再提供一些类，给java使用者使用即可。
    
##    ·继承Thread
        --重写run()?--创建实例--start启动
          
        不是类中所有代码都需要被线程执行，为区分哪些可以被线程执行，
        java提供了Thread类中的run()来包含那些被线程执行的代码。
        多线程耗时！
        若调用run()相当于，普通方法调用。
        start()：使该线程开始执行，JVM调用该线程的run方法。
    注意：IllegalThreadStateException非法线程状态异常，一个线程不能启用两次
    线程名称
        无参构造+setXXX()
    线程对象.getName()---> 源码分析Thread-0的由来
    线程对象.setName()--->
        带参构造
    new 线程("XXXName")；
    
    main是JVM调用的线程。
        static Thread currentThread();------------main
            
### 线程调度和控制
    CPU在某一时刻（比秒还精确）只能执行条指令，线程只有得到CPU时间片，
    即使用权，才能执行指令。
    ·Java是如何对线程进行调度的呢？抢占式调度,默认优先级5
        分时调度：所有线程，轮流使用，平均分配
        抢占式调度：按优先级高，分配时间片机率多一些
        
        注意：具有随机性，多次运行的取值。
    ·设置获取线程优先级max-10;norm-5;min-0;
        setPriority();
        getPriority();
    
    休眠：Thread.sleep(long l)---比秒还精确
    加入：对象.join() 等待该线程终止，让某些线程结束，我跑完了你们才能跑
    礼让：Thread.yield()，让多个线程更和谐，不能100%保证你一次我一次，但基本实现了
                    ---看后面的等待唤醒机制啥操作
    后台/守护：对象.setDaemon(boolean b),主线程死了，守护线程随之而死
        案例：坦克大战
    中断：对象.stop()---太暴力了，直接把该线程关了，后面不执行了
         对象.interrupt()----终止状态，抛出异常InterruptException，继续执行
    
### 线程生命周期
    新建：new----创建线程对象
    就绪：start()----有执行资格，无执行权
    运行：run--获取到CPU的执行权----有执行资格，有执行权
    
        阻塞：
            一些操作导致线程处于阻塞状态--sleep()/wait()
                  ---无执行资格，无执行权
            一些操作可以激活线程--sleep()时间到/notify()唤醒
                  ---回到就绪状态
                  
        失去CPU的执行权，被抢了 ---回到就绪状态
         
    死亡：run结束/中断线程----线程对象变为垃圾，等待回收
    
##    ·实现Runnable接口---一个run方法    
          --重写run()?--创建实例,作为构造参数--传递给Thread启动
      new Thread(myRun);    
           
    实现接口方式的好处：
        一个类有父类了，咋整？
            避免Java单继承的局限性。
        Thread里面有成员变量，new一次，创建一次，而Runable只创建一次！
            适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，
        数据有效分离，体现了面向对象的思想。
        
    案例：3个窗口卖100张票，共享100
        实现方式：继承Thread不如实现接口
        
        网络不能实时传输，存在延迟！
        遇到同票与负票的问题！！
            CPU每一次执行的操作是原子性的，在某一步被抢了（判断后，——后，3个线程）
            随机性和延迟（判断后，——后，3个线程可能都进来了）
            
### 线程安全问题
        条件：
            多线程 + 共享数据 + 多条语句操作共享数据（1.判断 2.-- 3.输出）
        解决：synchronized(对象){代码块}
            把多条语句操作共享数据包装成一个整体，像一个原子性----同步机制
        注意：
            解决问题的根因在于三个线程用一个对象，这个对象如同锁的功能。
            多个线程必须使用同一把锁。
### 同步
        特点：多个线程 + 使用同一个锁对象
        利：解决安全问题
        弊：每个线程都会去判断同步上的锁，耗费资源，降低程序运行效率。
        
        同步代码块
        锁对象：任意对象
        
        一个方法一进去就是同步--->同步加在方法声明上
        
        同步方法的锁对象：this
        静态同步方法的锁对象：当前类的字节码文件对象。类名.class
            例中if-同步代码块 else-同步方法 锁不是同一个--同票错误!
        注意：将同步代码块的锁 改为 同步方法的锁 (this)/类名.class
        
###     线程安全的类：几乎所有方法都加了synchronized
            StringBuffer 
            Vector
            Hashtable
        线程安全，效率低，不用Vector，用Collections的方法,产生的集合！
        List<String> list = Collections.synchronizedList(new ArrayList());