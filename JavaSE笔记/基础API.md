##现学现用
难在不知道要做什么---需求问题

#Object--万类之祖
    Java，不需要import就能引用到的类？
    第一种：java.lang下面的包。
    包的位置：%JAVA_HOME%/jre/lib/rt.jar
    
    Java语言中的java.lang包是由编译器直接自动导入的，
    java.lang包是Java语言的核心类库，包括了运行Java程序必不可少的系统类，
    如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等。
    每个Java程序运行时，系统都会自动地引入java.lang包，所以这个包的加载是缺省的。
    有没有注意到，你使用System/Exception/Math/String不需要import，因为这些类在java.lang下。
    java.lang是Java的基础类，唯一的，基础类，Java默认会import，
    所以java.lang下面的类不需要import。
    
    第二种：同包。

###     hashcode()  哈希值是根据哈希算法将地址值换算出来的整数值.不是实际地址值     
        不同对象的哈希值,可同可不同(存在引用赋值,同一个对象肯定相等)
###     getClass() 字节码文件对象(运行时类)
            ||
###     toString()  对象字符串表示(object中是getClass@16(hashcode)组合)
        直接输出对象名称  其实就是  输出对象的toString方法
###     equals()    比对象相等?  比的是引用类型  ，基本类型不能调用方法！
    但源码用  return(this == obj) 默认比的是地址值,意义不大
        == 比较的是 值,地址值
        重写:比较成员变量的内容是否相同.用==和String的equals()
        引用类型不能用==(地址值)比较.应该用equals比较(String类的equals重写了Object,比的是内容)
        
        对象 instanceof 类
        
###     protected finalize()    用于垃圾回收，什么时候回收，不知道。
###     protected close()     

##      protected访问范围是在异包子类中，不是其他类中，子类对象在其他类中也不行！！
###        重写可以解决无法调用object中的protected问题？？
        使用范围最高到异包子类，异包非子类就不行了，lang包和自定义的包为异包。
        testDemo里的main方法就是异包非子类。所以无法调用close() ！！
        重写clone()后,就变为同包非子类了，可以调用。
        
        
        没有方法的接口：标记接口，可以进行分类
        Cloneable ：实现该接口的类就可以实现对象复制！
        标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情.
        使用标记接口的唯一目的是使得可以用instanceof进行类型查询。
        一些容器例如Ejb容器，servlet容器或运行时环境依赖标记接口识别类是否需要进行某种处理。
        又如调用序列化方法时，就会检查你要序列化的那个对象是不是实现了Serializable接口，
        if (obj instanceof Serializable) 如果实现了就做预先约定好的操作，这里就是序列化。
        
###     浅克隆，与原来是独立的，改动不受影响。而两个引用指向同一个，改动有关系。


##Scanner--注意回车==\r\n空字符
因为nextLine();输入字符串时，遇到\r\n，就会结束读取，但是不读取\r\n。

##String的值是常量，引用是变量！一旦被赋值，值就不能改变，但可以引用传递！！（引用可变）
    直接赋值的方式其实是 先到方法区，字符串常量池里面去找，有就返回，无创建返回。
    字符串拼接就是先创建拼接对象，再创建整体赋值
    引用（变量）拼接先开空间！！再拼接
    常量拼接先找再创
    不可变，操作字符串效率低，浪费内存
    
    判断，获取，转换，其他（替换去除比较）。
###刘意    字符串会自动转换成一个字符数组！
    底层做了转换，没看到！
    
    jdk String 
    private final char value[] 属性是怎么初始化的？
    
    public String(String original) {
            this.value = original.value;
            this.hash = original.hash;
        }
    注意，传入的参数已经是一个String, 这个参数本身就具有一个char 
    数组value，所以用传入的String 本身的char数组赋值给新的String 的char 数组 
    
    
##StringBuffer 同步的字符串缓冲区--可变字符串--所有公开方法都有synchronized--多线程操作
    append()后返回的是其本身。没有开辟新的空间。
    添加append()与insert()
    删除
    替换
    反转
    截取（返回的是String，本身不变）
##  不能把字符串的值直接赋给StringBuffer.这是两个类！
    构造/append--->StringBuffer
    构造/toString--->String
    
    StringBuilder效率最高，数据不安全--可变字符串-----单线程操作

###    数组和StringBuffer都是容器
    StringBuffer随便放结果都是字符串
    数组只能放同一种的任意数据类型

##String是常量值，是一种特殊的引用类型！要当作基本类型来看，参数传递的是值，不影响实参。
##StringBuffer放的的是引用！
    形参和实参是两个变量！！各自独立！！ 引用赋值是指：多个引用只向同一个堆内存！
    方法里（形参）改变引用的值，不改变的堆里的值。不会对实参有影响！！
### 引用类型形参，赋值不变，操作变！
    形参是引用类型时，变化才会改变实参！！
    String 作为参数传递，效果和基本类型参数传递时一样的！
    赋值不变，操作改变？
    
##    方法进栈！开辟空间！
    基本数据类型也分情况，成员变量和所属的对象同在堆区，局部变量的话就分配在栈区，用完就消失了
    
    形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。
    因此，形参只在函数内部有效。函数调用结束，返回主调用函数后则不能再使用该形参变量。
    实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，
    在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。
    因此应预先用赋值，输入等办法使参数获得确定值。

    程序运行中有两个存储空间可用，一个是栈，是归属于进程本身的，
    另外一个是堆，所有进程共用的。局部变量在声明周期为函数内部，其存储空间位于栈中。
    当进入函数时，会对根据局部变量需求，在栈上申请一段内存空间，供局部变量使用。
    当局部变量生命周期结束后，在栈上释放。
    
#    JAVA中对象句柄的意思
    每种编程语言都有自己的数据处理方式。有些时候，程序员必须时刻留意准备处理的是什么类型。
    您曾利用一些特殊语法直接操作过对象，或处理过一些间接表示的对象吗（C或C++里的指针）？ 
    所有这些在Java里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，
    任何地方均可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个
    对象的“句柄”（Handle）。在其他Java参考书里，还可看到有的人将其称作一个“引用”，甚至
    一个“指针”。可将这一情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，
    就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是
    遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对
    电视机的控制，那么手上拿着的是遥控板，而非电视机。 
    此外，即使没有电视机，遥控板亦可独立存在。也就是说，只是由于拥有一个句柄，
    并不表示必须有一个对象同它连接。所以如果想容纳一个词或句子，可创建一个String句柄： 
    String s; 
    但这里创建的只是句柄，并不是对象。若此时向s发送一条消息，就会获得一个错误（运行期）。
    这是由于s实际并未与任何东西连接（即“没有电视机”）。因此，一种更安全的做法是：
    创建一个句柄时，记住无论如何都进行初始化： 
    String s = "asdf"; 
    然而，这里采用的是一种特殊类型：字串可用加引号的文字初始化。
    通常，必须为对象使用一种更通用的初始化类型。 

##  https://blog.csdn.net/CUG_ZG/article/details/79411591
    虚拟机在创建对象的时候，会优先查询常量池中是否有该对象的实例，
    如果没有则需要加载、解析、初始化class，然后分配内存，初始化内存，
    设置对象（HASH CODE 、 GC年代等），最后执行init才算是创建完对象。
    对象即实例。
        String str；
        以上的str就是一个句柄，但是并没有指向任何对象，好比这是一个客服中心，
        告诉你打400号码联系客服中心，但是没有指明是哪个客服人员，
        如果String str = "9527";这个时候就是说明了编号9527为您服务，可以通过句柄访问对象。
        直接指针，我理解的：
        class Test{
            public void doSth();
        }
        new Test().doSth();//直接指针
        Test() test = new Test();//句柄引用
        test.doSth();
        当然直接指针肯定是速度更快的，但是如果用句柄，对象被移动（比如GC），
        只需要改变指针而不会改变引用；如果是直接指针的方式，速度那是杠杠的，
        不用多余的一次指针的定位。综上，写JVM多用直接指针，写应用更多的是句柄。
        
##  https://blog.csdn.net/qq_23391049/article/details/80356479

    栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，
    用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，
    这个栈中的变量也将随之释放。

#       数组Array高级 与 工具类Arrays
    排序 
        冒泡：两两比较跑一遍，大的往后放。因为每次可以得到一个最大值！所以每一遍比较次数递减。共比数组长度-1次
        选择：我要一个打10个！（1-9）我要打9个！（2-9）打8个！（3-9）每次可以得到一个最小值！
        插入：同选择相反，和在第一个方向上依次比较
        归并：不断分裂直至11排序，分成1个不懂，另一组比完再和1比，11排序到组组排序
        快速：第一个由远及近比较，交换后，第二个继续刚才的比，交换一次，递进一次，继续
        希尔：先隔半匹配排序，再隔半半匹配。直至相邻11匹配
    查找
        基本（无序），从头找到尾，没有返-1
        二分（有序），

    二维数组与双重for有异曲同工之妙！

    
# 基本类型包装类的引入
    类里有成员变量，有方法，可以直接用！对基本类型进行更多操作！
    将基本类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据！
    常用于基本类型和字符串的转换
    
    进制的范围0-36==>因为0-9，a-z总共36
    反编译观察自动拆装箱！只是给编译器看的！
    
    使用自动拆装箱，不能为null，否则null.intValue()，报空指针异常。
    byte常量池[-128,127]---byte数据缓冲池----查看valueof()源码，超出byte常量池就new!
   
    https://www.cnblogs.com/to-creat/p/5891042.html
    
##    包装类的作用：
    集合不允许存放基本类型数据（数组可以），存放数字时，要用包装类型。
    自动拆装箱：
    也解决了集合中不能放基本类型的问题


#   链表的实现，为Java类集的框架服务
    链表是一种最基本的数据结构，依靠引用关系来实现多个数据的保存！一个链表==多个节点。
    火车车厢（节点）：1.货物==保存数据2.挂钩==下一个节点引用
    火车头==root
    挂钩(节点引用)==next
    如果哪个车厢的next==null，那么就是它最后一个节点
    Node是功能类（专门负责保存节点关系），不是简单Java类。由其他类负责Node关系匹配（挂节点）
    设置和取得数据（装货（设置数据内容）+ 挂钩（匹配关系））
    方法一循环取出，挂钩作为判断条件（while（挂钩 != null））
    方法二递归操作，（方法套方法，参数要变化（改为下一个挂钩））挂钩作为判断条件
    
    递归，参数(or调用对象)要有止境。
    
    设置和取数据，为什么要Node！直接数组不行吗？
    数据本身不具备先后关系，用Node来封装，并指向下一个节点（设置好了关系）。
    主方法就是客户端！目前做的有点多，自己动手处理Node关系，事实应该只关心数据的设置和取出！
    
##    改进：需要一个工具类实现关系处理
    通过之前的分析，可以发现链表的最大作用的类就是Node，
    但是以上程序都是由用户自己去匹配节点关系的，
    但是这些节点的匹配工作不应该由用户完成，应该由一个程序专门负责。
	那么专门负责这个节点操作的类，就称为链表类 —— Link，负责处理节点关系，
	而用户不需要关心节点问题，只需要关心Link的处理操作即可。
    客户端需要一个类隐藏链表中的细节操作（Node对象关系处理，数据增加输出）
    客户端只见Link操作，不见Node,Link来处理Node，与root有关
    第一个Node，自己就是火车头，他的node是下一个节点引用
    root-->第一个节点--->第二个节点--->第三个节点--->第四个节点--->null
    火车头的引用叫做root
    每个Node，显示指向下一个，但隐式的被前一个节点所指！
    链表是否有数据，判断root根即可。root有node指向就有数据(即第一个node节点有没有指向<root指向不空>！)
    每一个链表都有一个root。
    Link对象只关心root。
    创建链表new Link()，生成的root为空。
    保存第一个数据。root---> [Node(data)--->] null
    下一个数据怎么存？ 看当前节点的next有没有引用，不能用root判断,(递归寻找到next为空，每次从第一个节点开始找)
    第一次(Link)：this = Link.root
    第二次(Node)：this = Link.root.next
    (Node)Link.root.next.next
    (Node)Link.root.next.next.next
    ...
    Link只关心根节点root，Node关心next节点。 
    
    动态对象数组，此处单项无循环链表，最简单的
    链表最好的使用就是横向替代对象数组。

# 正则
    规则字符在java.util.regex.Pattern中
    
    Pattern是正则字符串的编译表示形式。
    判断,string.matches(regex);
    {}次数----\d==[0,9]  \w==[a-zA-Z_0-9]
    
    分割string.split("\\.");//以点分割
        string.split(" +");//以空格分割
        string.split("\\\\");//以程序中的路径分隔符分割（硬盘单杠，程序双杠）
    替换
        string.replaceAll(regex, replacement);
        
    获取 (匹配后才能获取)
    Pattern正则编译模式类(字符串)   Matcher匹配器(三种匹配，matchers整个\lookingat从头\find一个一个找子串)
    boolean b = Pattern.compile(regex).matcher(string).matches();
    ==string.matches(regex);
    单词边界\b,
    匹配后find 才能 group();
    
    
#   Math
        abs绝对值ceil天花板floor地板pow(a,b)a的b,sqrt开正根,max()，min(),
#   Random
        public Random(long seed)有种子（给出指☞定的种子）每次得到的随机数是相同的
        public Random() 无种子（默认当前时间的毫秒值）
        public int nextInt()返回int范围内的随机数
        public int nextInt(int n)返回[0，n)范围内的随机数
#   System
        System.gc();会自动调用finalize()方法。先释放自己，再释放父类对象。
        
        finalize()一般是用不到的，除非JVM认为已经没有内存可以使用了，
        那时JVM才会消耗资源去清理垃圾，所以finalize()也不能作为通用的清理方法。
        而且finalize()有一个比较另类的用法，就是说finalize()并不依赖对它的直接调用，
        它有某些触发问机制，比如说对象已经标明要被终结，这时会自动答执行版finalize()。
        并不需要去显式的调用，这也是为什么代码中没有显式调用finalize()，
        但它确实执行了的原因，因为它触发了finalize()的执行条件。
        其实不必太在意finalize()，因为一般的程序中是使用不到finalize()的，
        所以那些开发Java的大牛们把finalize()的用法整的很隐晦，
        而且它们把垃圾回收机制做的比较自动化，一般不需要手工清理。
        
        finalize()方法并没有什么鸟用，（并且在新版JAVA中已被弃用）。
        至于为什么会存在一个鸡肋的方法：书中说“它不是C/C++中的析构函数，
        而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协”《JAVA编程思想》。
        
        
        exit(int status);终止当前的Java虚拟机。status=0表示正常退出
        currentTimeMillis();返回毫秒值，可用来⏲计时。
        arryccopy(源数组，源数组起始位置，目标数组，目标数组起始位置，复制数量);复制指定数组,替换到指定数组位置
        arryccopy(arr,1,arr2,2,2);
        
#   BigInteger 超过Integer范围的数据进行计算2147483648
        BigInteger(String s);
        +=*/
        add(),subtract(),multiply(),divide(),divideAndRemainder()返回商和余数的数组
#   BigDecimal    解决（float与double）精度问题（有效数字位）
        BigDecimal(String s);
        add(),subtract(),multiply(),divide(),
        
#   日期类Date    毫秒值重写是给外国人看的
        获取毫秒值
#   格式类              给中国人看
#   抽象类DateFormat   format(date);
    子类SimpleDareFormt()
        SimpleDareFormt("yyyy年MM月dd日 HH:mm:ss")
        String s = sd.format(date);// 把date转成字符串
        把字符串转成date,构造方法中的格式必须和给定的格式匹配
        Date d = sd.parse(s);
        
#   日历类：封装了所有的日历字段值，日期计算很方便
#   Calendar抽象类    闰月闰年2月非此不可
    Calendar.getInstance().get(Calendar.YEAR);
    add(Calendar.YEAR, int +-i);  // 随意更改时间
    set(int y, int m + 1, int d); // 随意设置时间
    
    补充：用instanceof来判断实例对象的类型是否实现了一个给定的标识接口
    
    
    
    
    
    