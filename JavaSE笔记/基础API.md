##现学现用
难在不知道要做什么---需求问题

#Object--万类之祖
    Java，不需要import就能引用到的类
    第一种：java.lang下面的包。
    Java语言中的java.lang包是由编译器直接自动导入的，
    java.lang包是Java语言的核心类库，包括了运行Java程序必不可少的系统类，
    如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等。
    每个Java程序运行时，系统都会自动地引入java.lang包，所以这个包的加载是缺省的。
    有没有注意到，你使用System/Exception/Math/String不需要import，因为这些类在java.lang下。
    java.lang是Java的基础类，唯一的，基础类，Java默认会import，
    所以java.lang下面的类不需要import。
    
    第二种：同包。

###     hashcode()  哈希值是根据哈希算法将地址值换算出来的整数值.不是实际地址值     
        不同对象的哈希值,可同可不同(存在引用赋值,同一个对象肯定相等)
###     getClass() 字节码文件对象(运行时类)
            ||
###     toString()  对象字符串表示(object中是getClass@16(hashcode)组合)
        直接输出对象名称  其实就是  输出对象的toString方法
###     equals()    比对象相等?  比的是引用类型  ，基本类型不能调用方法！
    但源码用  return(this == obj) 默认比的是地址值,意义不大
        == 比较的是 值,地址值
        重写:比较成员变量的内容是否相同.用==和String的equals()
        引用类型不能用==(地址值)比较.应该用equals比较(String类的equals重写了Object,比的是内容)
        
        对象 instanceof 类
        
###     protected finalize()    用于垃圾回收，什么时候回收，不知道。
###     protected close()     

##      protected访问范围是在异包子类中，不是其他类中，子类对象在其他类中也不行！！
###        重写可以解决无法调用object中的protected问题？？
        使用范围最高到异包子类，异包非子类就不行了，lang包和自定义的包为异包。
        testDemo里的main方法就是异包非子类。所以无法调用close() ！！
        重写clone()后,就变为同包非子类了，可以调用。
        
        
        没有方法的接口：标记接口，Cloneable，
        告诉我们：实现该接口的类就可以实现对象复制！
        使用标记接口的唯一目的是使得可以用instanceof进行类型查询。
###     浅克隆，与原来是独立的，改动不受影响。而两个引用指向同一个，改动有关系。


##Scanner--注意回车==\r\n空字符
因为nextLine();输入字符串时，遇到\r\n，就会结束读取，但是不读取\r\n。

##String的值是常量，引用是变量！一旦被赋值，值就不能改变，但可以引用传递！！（引用可变）
    直接赋值的方式其实是 先到方法区，字符串常量池里面去找，有就返回，无创建返回。
    字符串拼接就是先创建拼接对象，再创建整体赋值
    引用（变量）拼接先开空间！！再拼接
    常量拼接先找再创
    
    判断，获取，转换，其他（替换去除比较）。
###刘意    字符串会自动转换成一个字符数组！
    底层做了转换，没看到！
    
    jdk String 
    private final char value[] 属性是怎么初始化的？
    
    public String(String original) {
            this.value = original.value;
            this.hash = original.hash;
        }
    注意，传入的参数已经是一个String, 这个参数本身就具有一个char 
    数组value，所以用传入的String 本身的char数组赋值给新的Sttring 的char 数组 
    
    
##StringBuffer 同步的字符串缓冲区
    append()后返回的是其本身。没有开辟新的空间。
    添加append()与insert()
    删除
    替换
    反转
    截取返回的是String，本身不变
##  不能把字符串的值直接赋给StringBuffer.这是两个类！
    构造/append--->StringBuffer
    构造/toString--->String
    
    StringBuilder效率最高，数据不安全

###    数组和StringBuffer都是容器
    StringBuffer随便放结果都是字符串
    数组只能放同一种的任意数据类型

##String是常量值，是一种特殊的引用类型！要当作基本类型来看，参数传递的是值，不影响实参。
##StringBuffer放的的是引用！
    形参和实参是两个变量！！各自独立！！ 引用赋值是指：多个引用只向同一个堆内存！
    方法里（形参）改变引用的值，不改变的堆里的值。不会对实参有影响！！
### 引用类型形参，赋值不变，操作变！
    形参是引用类型时，变化才会改变实参！！
    String 作为参数传递，效果和基本类型参数传递时一样的！
    赋值不变，操作改变？
    
##    方法进栈！开辟空间！
    基本数据类型也分情况，成员变量和所属的对象同在堆区，局部变量的话就分配在栈区，用完就消失了
    
    形参变量只有在被调用时才分配内存单元，在调用结束时，
    即刻释放所分配的内存单元。因此，形参只在函数内部有效。
    函数调用结束返回主调用函数后则不能再使用该形参变量。
    实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，
    在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。
    因此应预先用赋值，输入等办法使参数获得确定值。

    程序运行中有两个存储空间可用，一个是栈，是归属于进程本身的，
    另外一个是堆，所有进程共用的。局部变量在声明周期为函数内部，其存储空间位于栈中。
    当进入函数时，会对根据局部变量需求，在栈上申请一段内存空间，供局部变量使用。
    当局部变量生命周期结束后，在栈上释放。
    
#    JAVA中对象句柄的意思
    每种编程语言都有自己的数据处理方式。有些时候，程序员必须时刻留意准备处理的是什么类型。
    您曾利用一些特殊语法直接操作过对象，或处理过一些间接表示的对象吗（C或C++里的指针）？ 
    所有这些在Java里都得到了简化，任何东西都可看作对象。因此，我们可采用一种统一的语法，
    任何地方均可照搬不误。但要注意，尽管将一切都“看作”对象，但操纵的标识符实际是指向一个
    对象的“句柄”（Handle）。在其他Java参考书里，还可看到有的人将其称作一个“引用”，甚至
    一个“指针”。可将这一情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，
    就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是
    遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对
    电视机的控制，那么手上拿着的是遥控板，而非电视机。 
    此外，即使没有电视机，遥控板亦可独立存在。也就是说，只是由于拥有一个句柄，
    并不表示必须有一个对象同它连接。所以如果想容纳一个词或句子，可创建一个String句柄： 
    String s; 
    但这里创建的只是句柄，并不是对象。若此时向s发送一条消息，就会获得一个错误（运行期）。
    这是由于s实际并未与任何东西连接（即“没有电视机”）。因此，一种更安全的做法是：
    创建一个句柄时，记住无论如何都进行初始化： 
    String s = "asdf"; 
    然而，这里采用的是一种特殊类型：字串可用加引号的文字初始化。
    通常，必须为对象使用一种更通用的初始化类型。 

##  https://blog.csdn.net/CUG_ZG/article/details/79411591
    虚拟机在创建对象的时候，会优先查询常量池中是否有该对象的实例，
    如果没有则需要加载、解析、初始化class，然后分配内存，初始化内存，
    设置对象（HASH CODE 、 GC年代等），最后执行init才算是创建完对象。
    对象即实例。
        String str；
        以上的str就是一个句柄，但是并没有指向任何对象，好比这是一个客服中心，
        告诉你打400号码联系客服中心，但是没有指明是哪个客服人员，
        如果String str = "9527";这个时候就是说明了编号9527为您服务，可以通过句柄访问对象。
        直接指针，我理解的：
        class Test{
            public void doSth();
        }
        new Test().doSth();//直接指针
        Test() test = new Test();//句柄引用
        test.doSth();
        当然直接指针肯定是速度更快的，但是如果用句柄，对象被移动（比如GC），
        只需要改变指针而不会改变引用；如果是直接指针的方式，速度那是杠杠的，
        不用多余的一次指针的定位。综上，写JVM多用直接指针，写应用更多的是句柄。
        
##  https://blog.csdn.net/qq_23391049/article/details/80356479

    栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，
    用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，
    这个栈中的变量也将随之释放。


















