
左栈new堆（new在堆）方法区

栈中是局部变量，必须初始化。生命周期同方法
堆中是成员变量，有默认值。生命周期同对象
方法区的静态区是静态变量，所属类，生命周期同类


###栈中用完就销毁！！！
堆中若无栈指，会被GC！匿名对象!!!                             
###Java中调用方法关于参数传递问题----Java中只有值传递
    *基本类型传递的是值！
        *故形参改变不影响实参（不是同一个变量）
    *引用类型传递的地址值
        **故形参改变直接影响实参（是同一个内存地址）
###------两个引用指向同一个堆内存！！！！！！

引用类型：数组，类如String，接口如List<E>。。。


引用类型在堆里，基本类型在栈里。new的都在堆里
栈空间小且连续，往往会被放在缓存。引用类型cache miss率高且要多一次解引用。
对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高



###面向对象是基于面向过程的编程思想
面向过程：强调的是每一个功能的步骤！ 
面向对象：强调的是对象，然后由对象去调用功能！

###  耦合度高，后期维护难！！----------解耦！！  维护方便！！！
面向对象 本身就是第一次进行解耦！！


#  封装
封装的一种体现private，还产生了this关键字（当前类的对象的引用即类的一个对象，谁调用方法,this就是谁的）
this在这里解决了局部变量隐藏成员变量的问题（set/get方法里的问题）！


return;=====结束void方法

封装好处
private与set/get的关系，多行代码比一行代码复用率高；set/get提高数据安全；隐藏实现细节，提供公共的访问方式。


隐藏任务 
默认提供隐藏的构造器！！无void


Student s = new Student();
类的初始化过程
1，加载字节码进内存
2. 开栈（变量s）
3. 开堆（对象）
4. 变量默认初始化（Student类里有赋值就是显示初始化）
5. 构造方法（赋值）
6. 初始化完毕（即堆中OK了），才把对象地址值赋给栈中变量


当存在固定的属性值（多个对象共用）时，为节省堆内存空间（每次创建对象，都要开辟空间），static


static随着类加载而加载psvm,被所有对象共享。可以通过类名调用--------被static修饰的称为类成员


psvm测试类的作用，创建其他类的对象，调用其他类的功能。

把构造对象私有化，外界就不能创建对象了---李兴华在此引出了单例？？
                                                


##  四大代码块---{}    
###特征---没有方法名！！！

 局部代码块{}----类中方法中（局部位置），限定生命周期，用完即死，提高内存利用率！
 
 构造代码块{}--(描述对象的)--类中方法外（成员位置），同构造方法位置。且每次调用构造方法，都会在构造方法之前执行一次。
        用处：可以将多个构造器方法中相同的代码存放在这个构造代码块{}中。对对象初始化!!
        
 静态代码块static{}--(描述类的)--类中方法外（成员位置），用static修饰， 只在类初始化时执行一次。对类初始化！！
 
 同步代码块----多线程

###一个类有多个对象 ====>>>>    一个static多个构造。方法归方法区。有调用才执行！！！

##代码块执行顺序-----与所在位置无关
静态代码块 先于main方法执行-->构造代码块-->构造方法------------->>>其他静态方法


因为main方法也得调用方法，加载class时，还没有调，走完static，jvm才调用main。然后运行代码并加载main方法中需要的类（字节码）。
    加载类先从它继承的祖宗开始static{}
###由此得出---- 类的加载时机不是编译时，而是运行时！！！




# 继承---is a 
功能代码相同，可以抽取方法
类成员相同，怎么办？？   可以抽取吗？？ 
extends----提高代码复用性，可维护性（改一个就行了）。
            使类与类产生了联系！这既是多态的前提，又增加了类的耦合性！！
 

开发原则：低耦合（类与类的关系），高内聚（自己完成某件事的能力）

###特点-- 单继承 但存在 多层继承（传递继承），
       -- 只能继承非私有的成员，如可以调用父类公共方法（父类公共方法用到了自己里面的私有变量也是Ok）---打破了封装性（类里的东西不被别人访问）
       -- 不继承构造方法，可用super访问！
 


###继承中，成员变量的关系。
   --就近原则
   --子局部--子成员--到父成员--父的父的成员变量...... （不到父局部，不调用方法怎么访问？）
    注： 各个方法之间是平级关系，方法不能见到另一个方法内部的变量


    局部变量名 ---(成员)this.变量名 -- (父类)super.变量名


this===本类对象的引用
super==父类存储空间的标识（可理解为父类的引用）
this与super均可   this.成员变量方法和构造方法/super.成员变量方法和构造方法

###继承中，构造方法的关系。---------父系继承

### 子类中所有的构造方法（有参无参），默认都会访问  父系中 无参的构造方法。

    因为 子类会继承父类中的数据，可能会是使用父类的数据。如果数据没有初始化，子类无法访问。
    所以子类初始化前，一定要先完成父类 数据的初始化。
### 强制措施：每一个构造方法的第一条语句默认都是   super();
  如果父系没有无参构造器，会报错的！！！
  所以要么，添加无参；
     要么子类添加super(带参);显示访问父系其他构造方法；
     要么子类添加this();通过本类其他构造-间接-访问父类无参构造。进行数据初始化！
     super与this()必须第一句，否则父类会多次初始化，报错的

super仅仅意味着必须先初始化父类数据。。。再初始化子类数据。如果父类已经初始化了，super也就没用了！！
调用构造方法前，先调成员变量


###一个类的初始化过程
    1.成员变量进行初始化
        默认初始化--0
        显示初始化--赋值
        构造方法初始化--

##子类初始化之前先进行父类初始化！！！


###继承====加载顺序====>>>>先有祖宗后有子孙！！！分层初始化
类加载时，static祖宗先，
类加载后，走构造，祖宗构造代码块先，然后无参构造祖宗先---子孙构造代码块--子孙构造方法

int x = 10; //成员变量是基本类型
Y b = new Y(); //成员变量是引用类型


虽然子类中构造默认有一个super();
但是初始化的时候，不是按照那个顺序进行的。而是按照分层初始化进行的！！
它仅仅表示要先初始化父类数据！！再初始化子类数据！！！


###如果父类已经初始化了，super也就没用了！！










