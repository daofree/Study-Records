
左栈new堆（new在堆）方法区

栈中是局部变量，必须初始化。生命周期同方法
堆中是成员变量，有默认值。生命周期同对象
方法区的静态区是静态变量，所属类，生命周期同类


###栈中用完就销毁！！！
堆中若无栈指，会被GC！匿名对象!!!                             
###Java中调用方法关于参数传递问题----Java中只有值传递
    *基本类型传递的是值！
        *故形参改变不影响实参（不是同一个变量）
    *引用类型传递的地址值
        **故形参改变直接影响实参（是同一个内存地址）
###------两个引用指向同一个堆内存！！！！！！

引用类型：数组，类如String，接口如List<E>。。。


引用类型在堆里，基本类型在栈里。new的都在堆里
栈空间小且连续，往往会被放在缓存。引用类型cache miss率高且要多一次解引用。
对象还要再多储存一个对象头，对基本数据类型来说空间浪费率太高



###面向对象是基于面向过程的编程思想
面向过程：强调的是每一个功能的步骤！ 
面向对象：强调的是对象，然后由对象去调用功能！

###  耦合度高，后期维护难！！----------解耦！！  维护方便！！！
面向对象 本身就是第一次进行解耦！！


#  封装
封装的一种体现private，还产生了this关键字（当前类的对象的引用即类的一个对象，谁调用方法,this就是谁的）
this在这里解决了局部变量隐藏成员变量的问题（set/get方法里的问题）！


return;=====结束void方法

封装好处
private与set/get的关系，多行代码比一行代码复用率高；set/get提高数据安全；隐藏实现细节，提供公共的访问方式。


隐藏任务 
默认提供隐藏的构造器！！无void


Student s = new Student();
###类的初始化过程----类的加载，内存的分配，默认值的设置，构造方法。
1，加载字节码进内存
2. 开栈（变量s）
3. 开堆（对象）
4. 变量默认初始化（Student类里有赋值就是显示初始化）
5. 构造方法（赋值）
6. 初始化完毕（即堆中OK了），才把对象地址值赋给栈中变量


当存在固定的属性值（多个对象共用）时，为节省堆内存空间（每次创建对象，都要开辟空间），static


static随着类加载而加载psvm,被所有对象共享。可以通过类名调用--------被static修饰的称为类成员


psvm测试类的作用，创建其他类的对象，调用其他类的功能。

把构造对象私有化，外界就不能创建对象了---李兴华在此引出了单例？？
                                                


##  四大代码块---{}    
###特征---没有方法名！！！

 局部代码块{}----类中方法中（局部位置），限定生命周期，用完即死，提高内存利用率！
 
 构造代码块{}--(描述对象的)--类中方法外（成员位置），同构造方法位置。且每次调用构造方法，都会在构造方法之前执行一次。
        用处：可以将多个构造器方法中相同的代码存放在这个构造代码块{}中。对对象初始化!!
        
 静态代码块static{}--(描述类的)--类中方法外（成员位置），用static修饰， 只在类初始化时执行一次。对类初始化！！
        主类中先与main方法执行，导致1.7之前不用main()方法，也可以执行的漏洞！！
 
 同步代码块----多线程

###一个类有多个对象 ====>>>>    一个static多个构造。方法归方法区。有调用才执行！！！

##代码块执行顺序-----与所在位置无关
静态代码块 先于main方法执行-->构造代码块-->构造方法------------->>>其他静态方法


因为main方法也得调用方法，加载class时，还没有调，走完static，jvm才调用main。然后运行代码并加载main方法中需要的类（字节码）。
    加载类先从它继承的祖宗开始static{}
###由此得出---- 类的加载时机不是编译时，而是运行时！！！




# 继承---is a 
功能代码相同，可以抽取方法
类成员相同，怎么办？？   可以抽取吗？？ 
extends----提高代码复用性，可维护性（改一个就行了）。
            使类与类产生了联系！这既是多态的前提，又增加了类的耦合性！！
 

开发原则：低耦合（类与类的关系），高内聚（自己完成某件事的能力）

###特点-- 单继承 但存在 多层继承（传递继承），
       -- 只能继承非私有的成员，如可以调用父类公共方法（父类公共方法用到了自己里面的私有变量也是Ok）---打破了封装性（类里的东西不被别人访问）
       -- 不继承构造方法，可用super访问！
 


###继承中，成员变量的关系。
   --就近原则
   --子局部--子成员--到父成员--父的父的成员变量...... （不会到父局部，因为不调用方法怎么访问？）
    注： 各个方法之间是平级关系，方法不能见到另一个方法内部的变量


    局部变量名 ---(成员)this.变量名 -- (父类)super.变量名


this===本类对象的引用
super==父类存储空间的标识（可理解为父类的引用）
this与super均可   this.成员变量方法和构造方法/super.成员变量方法和构造方法

###继承中，构造方法的关系。---------父系继承

### 子类中所有的构造方法（有参无参），默认都会访问  父系中 无参的构造方法。

    因为 子类会继承父类中的数据，可能会是使用父类的数据。如果数据没有初始化，子类无法访问。
    所以子类初始化前，一定要先完成父类 数据的初始化。
### 强制措施：每一个构造方法的第一条语句默认都是   super();
  如果父系没有无参构造器，会报错的！！！
  所以要么，添加无参；
     要么子类添加super(带参);显示访问父系其他构造方法；
     要么子类添加this();通过本类其他构造-间接-访问父类无参构造。进行数据初始化！
     super与this()必须第一句，否则父类会多次初始化，报错的

super仅仅意味着必须先初始化父类数据。。。再初始化子类数据。如果父类已经初始化了，super也就没用了！！
调用构造方法前，先调成员变量


###一个类的初始化过程
    1.成员变量进行初始化
        默认初始化--0
        显示初始化--赋值
        构造方法初始化--

##子类初始化之前先进行父类初始化！！！


###继承====加载顺序====>>>>先有祖宗后有子孙！！！分层初始化
类加载时，static祖宗先，
类加载后，走构造，祖宗构造代码块先，然后无参构造祖宗先---子孙构造代码块--子孙构造方法

int x = 10; //成员变量是基本类型
Y b = new Y(); //成员变量是引用类型


虽然子类中构造默认有一个super();
但是初始化的时候，不是按照那个顺序进行的。而是按照分层初始化进行的！！
它仅仅表示要先初始化父类数据！！再初始化子类数据！！！


###如果父类已经初始化了，super也就没用了！！

构造方法里有成员变量！！所以肯定先成员变量！！

###继承中，成员方法的关系。---就近原则
  子类-->父类
  方法重写可以先用super.方法();  继承父类功能代码，再增强自己的。。
  
###  注意
    1. 私有方法不能被重写
    2. 访问权限不能降低，（防止功能断代）
    3. 静态方法重写同样要静态 (但算不上方法的重写,静态方法是与类相关的)
    
    方法重载（一个类中）与返回值类型无关。能改变返回值类型
    方法重写（继承中），不能改变返回值类型
    
    
    
    
 ##   子类继承父类----------可以重写，不给重写咋整？？  final来了
    
    修饰类---------不被继承
    修饰方法-------不被重写
    修饰成员变量----不被修改（重新赋值）
    修饰局部变量----在方法声明上--传递的值（基本类型与引用类型）不能被改变（地址值不可变，地址里的内容可变）
    
    final  默认值后，只能被赋值一次
    修饰变量在对象构造完毕前即可。
    字面值常量"hello"与自定义常量final x
    
##多态   ---右边是左边（继承是前提）
    前提：要有 继承 + 方法重写(多态才有意义) + 父类引用指向子类
    
##多态特点    ---由于成员方法存在重写,故运行看右边
    成员变量------编译看左边，运行看左边。
    构造方法------创建子类对象时,访问父类方法,对父类数据进行初始化
    成员方法------编译看左边，运行看右边。
    静态方法------编译看左边，运行看左边。(静态方法是与类相关的,算不上重写,所以,访问的还是左边)
    
##让工具类不能有对象
    
##多态好处
    提高维护性(继承保证)
    提高扩展性(多态保证)(工具类参数用父类接受,不用添加了)
##多态弊端
    不能使用子类特有的功能   
##处理弊端
    新建对象占内存;
    用向下转型(父类引用强转为子类的引用(还给))(向上转型==多态)
    
    
### 内存图解:方法区-->类加载区--静态方法区(static main())   
    main方法进栈-->Fu f
    -->进堆-->new z()-->先super区(初始数据,关联父方法区)后this区(初始数据,关联方法区-先继承后重写覆盖)
    
        成员变量是外在特征描述--父
        方法是内在特征功能描述--子
    (或者找方法时,先找父方法,然后有重写,再找父方法,没了报错)
    (类加载后，走构造，祖宗构造代码块先，然后无参构造祖宗先---子孙构造代码块--子孙构造方法)
    访问父类对象有没有造父类对象??--没有--super
    
    堆子-----要初始化子,先初始化父

重写--在继承里面---继承==隐形拥有




##抽象类--不能实例化--抽象类多态

抽象类中不一定有抽象方法,
有构造方法,但不能实例化.
抽象类的构造方法的作用是什么,用于子类访问父类数据的初始化.

要通过多态实例化!!
多态具体使用是在抽象中使用.


多态,一个对象,多个实例赋值


抽象类可以没有抽象方法.意义在于:不让外界创建对象.只有通过子类访问.
###abstract不能和谁共存?组合
    static 与 abstract 组合无意义.静态可以通过类调用(调用抽象方法)
    private 冲突
    final 冲突

##接口interface---定义额外功能,不给具体实现
抽象是从具体事务中总结出来的共性.
接口是对某些具体的事务功能进行额外的补充扩展;并不是所有子类的共性.不应该被继承..

##interface特点
    interface 接口名{}===>没有class,说明不是实际意义上的类,是功能的扩展
    不能实例化
    子类实例化,接口多态
    要么抽象类要么重写

##多态3种形式:
    1.具体多态
    2.抽象多条(常用)
    3.接口多态(最常用)
    
##接口成员特点

    成员变量:只能常量 默认public static final
    构造方法:没有,接口是扩展功能的,没有具体存在.通过子类实现(数据都是static final,不用初始化)
    成员方法:只能抽象 默认public abstract


接口无构造方法,那么其实现子类的构造里默认的super咋整?------所有类默认继承Object(超类)
因为Object设计时只提供了无参构造,所以要求其所有子类默认调用无参构造.有参有几个参呢？？干脆一个别给！就是无参


##类与类---单继承关系--多次单继承
##类与接口--单多实现,关系--单多(,)还能继承实现
##接口与接口--单多继承关系--单,接口多继承

##抽象类与接口
    成员-
        接口:只常,无构,只抽或无
        抽象:可变,有构,可抽
    关系-
    设计理念
        抽象类被继承 体现    is a ---共性功能
        接口被实现 体现 like a ---扩展功能


##形参和返回值问题
###   形参
        基本类型
        引用类型
            1.类--需要该类的对象
            2.抽象类--其子类对象
            3.接口--其实现类对象

###   返回值
        基本类型
        引用类型
            1.类--该类的对象
            2.抽象类--其子类对象
            3.接口--其实现类对象


链式编程:每次调用完毕后,返回的是一个对象.


##package包==文件夹
    区分相同的类名,对类进行分类编辑
    按模块按功能分
    程序第一行且只有一行.
    编译:javac -d . HeleoWorld.java
    运行:java cn.daofree.Helloworld
    不同包下的类之间的访问,如果没有import,就都需要加包的全路径.
    
##权限修饰符--无关其他---2类4变4构4方
    public---异包无关类
    protected--异包只子类用----给子类用,只在方法变量上,不能在类上
    
    默认--兄弟(可访问同包其他类及方法)--同包下子类无关类都可以
    private--自己(只在同一类中)    

##状态修饰符:--1类(static不能修饰外部类) 2变0构2方
    static,final
    
##抽象修饰符---1类0变0构1方
    abstract

#背景:我调用你方法,你输出我变量.我中有你,你中有我。（解决 一个类访问另一个类的私有属性 的情况，外访内，内访外）
    若把内部类Inner放外面,这个Inner类还要访问另一个类Outer的私有属性,
    这个在外的Inner类需要创建Outer实例化对象调用其get方法.
    另一个类Outer需要定义get方法,<已有fun方法(实例Inner,调用Inner方法)>
    再创建Outer类对象调用fun方法
    为避免这个过程中创建了两个Outer对象.把main方法的out通过构造方法传递过去.
##    结论:内部类牺牲了程序结构(类中类),达到了内可访外的目的.
#内部类--好处可以大大简化私有属性的访问(内部类放外面)
    访问特点:
        内可直接访外(包括private),(就近原则,num,this.num,Outer.this.num)
        外要通过内部类对象访问内部   (内部类与成员方法同级,不能直接使用内部类里面的方法)
        
    分类-成员/局部
    #######################
        成员内部类:  Outer.Inner oi = new Outer().new Inner();
            
##内部类常见修饰符(内部类一般不让外界直接访问)
    private 保证数据安全性(外部类先判断再使用内部类)
    static 让数据访问更方便(),但new Outer().new Inner();会报错.
        Outer.Inner oi = new Outer.Inner();// 仿佛一个Outer.Inner独立的类/Outer$Inner.class
        $是文件名,换回程序是.=====>内部类名称="外部类.内部类"
        --类要通过对象调用其方法,所以要创建对象,外部类限定的(静态直接调用)
        "类.类.类" ===>    static修饰的内部类
        Outer.Inner.静态方法();
###静态类不可用外部对象访问.
    
    内部类用静态修饰是因为内部类可以看成是外部类的成员    
    如果一个内部类,使用static定义的话,那么这个内部类就变为了一个外部类,并且只能访问static操作.
## static修饰的是类变量,类里面的变量,随类的加载而加载
    静态内部类里面的静态/非静态方法 访问的外部类数据必须是static修饰
    
    
    内部类与外部类,没有继承关系.
##如何访问外部非静态的成员变量?   外部类名限定this对象,外部类的当前对象
    new Outer().变量/Outer.this.num;
    
    #######################
        局部内部类(成员方法里):
    特点:
        可以直接访问外部类的成员.
        在局部位置(方法里),可以创建内部类对象,通过对象调用内部类方法,来使用局部内部类功能.
        
###局部内部类 访问 局部变量,形参变量(方法参数)..注意事项?  (1.8版本之前要求,之后不要final也可以获取值)
    局部变量必须被final修饰,才能在方法里面创建局部内部类对象,调用局部内部类方法使用它
##为什么??
    因为局部变量会随着方法的调用而调用,随着调用完毕(代码走完)而消失.
    此时,局部对象(局部内部类对象)并没有立马从堆内存(垃圾回收器空闲处理)中消失,还要使用那个变量.
    为了让数据还能继续使用,就用final修饰,称为常量.这样,在堆内存里面存储的是一个常值.不是一个变量名.
    通过反编译工具可以看一下.代码里是一个常值.不是一个变量名.
    
    备注：以后方法内部类最常用！框架
    
#静态怎么可能修饰局部变量.
    静态要先加载,但是方法还没加载.矛盾

###    成员方法中的局部变量,局部内部类只能访问不能修改，为什么？
    本质是内存分布空间的不同，栈和堆的垃圾回收机制不同，为保持数据同步作出的规定。
    这就要提到类的生命周期(Java_类的生命周期(类的加载与垃圾回收))。
    类初始化的过程中会首先在方法区（在堆中）为静态属性分配内存并赋值
    在对象实例化时会对类的成员属性在堆中分配内存赋默认值。
    而局部变量则不同，局部变量是存储在栈中。
###    那堆中和栈中有什么不同呢？
    这和垃圾回收机制有关：
    栈中的局部变量不需要专门的垃圾回收，方法入栈，局部变量创建，方法出栈，局部变量清除。
    而堆中有专门的垃圾回收机制((Java_类的生命周期(类的加载与垃圾回收)))。
    所以内部类虽然在方法中，但是它的内存是分配在堆中的，
    而方法在栈中出栈时，在堆中内部类对象并不会立刻被回收，
    如果内部类可以修改方法中的局部变量话，一旦方法已经出栈，
    而内部类的对象仍然存在被其它引用或者在堆中没有被垃圾回收，这个时候就会出现矛盾。
    所以这就规定内部类只能访问方法中的局部变量（访问其实也是局部变量的副本，
    符合Java_值传递原则（基本数据类型实参向形参传递参数的副本，引用数据类型传递的是引用的地址值），
    不能修改局部变量。

   
   抽象类的外部抽象类不能用static，内部类可以！！（staic修饰内部类属于外部类）
   
   有些时候，抽象类只需要一个特定的系统子类操作。可以忽略掉外部子类，即成员内部抽象类子类
    
一个java类一个文件，一个类只用一次
局部内部类发展再进化...类都省了,不用再内部类创建对象调用内部类里的方法,直接写实现方法的对象(不创建了)

##匿名内部类(位置同局部内部类)--局部内部类的简化写法--本质不是一个类
    前提:
        存在一个类(具体or抽象)或者接口
    
    格式--是个对象,没调用
        new 类名或者接口名(){
            //重写方法
            public void show(){
                ...
            }
        };
    
    本质
        分析:new 是分配内存-造对象!
        结论:一个 继承了该类或者实现了该接口的子(实现)类 匿名 对象
    
    使用
    --
    +
    
        有一个方法
            对象.方法();
        有多个方法
            多态对象接收--再点方法.
            
    应用--少写一个具体实现类
        引用类型(接口)的情况(形参),需要的是子(实现)类对象.
        引用类型里的方法仅调用一次.
        匿名内部类就是一个子类匿名对象.
          
    匿名内部类用完就回收,栈中没有指向.一次性的.
    
    
    注意
        访问 局部变量,形参变量(方法参数)..注意事项?  (1.8版本之前要求,之后不要final也可以获取值)
    
    
    
##    基本类型在虚拟机中是存储在栈中。
    https://www.cnblogs.com/mataoshou/p/10819586.html





