    同步代码块和同步方法的锁，靠理解加锁和释放，看不清晰
    JDK5提供的接口Lock,专门加锁释放锁，lock(),unlock()，看的清晰，功能更强大
    实现类ReentrantLock

# 死锁----多个线程，多个锁，争夺资源，互相等待
    同步弊端：效率低，同步嵌套易死锁。（我用你的锁，你用我的锁）
    案例:
    if(T)-else(F),两个{}，每个{}，两个synchronized嵌套，两个锁
    
# 线程间通信---不同种类的线程间针对同一资源的操作。
    生产者与消费者模式
    
    生产者线程生产，消费者线程消费。设置线程，获取线程
    
    注意：同一资源，不能每个线程都new资源！
    实现：在外界把这个数据创建出来，通过构造方法传递给其他类！
    问题：
         1.生产者与消费者不是作用同一对象
         2.未生产，已消费！
         3.循环判断生产不同值，消费乱套
             同一数据多次--生产一个，消费多个（CPU执行太快了）
             name/age不匹配，刚赋值一个，执行权被抢了--随机性
    解决：加锁--同步代码块
        给生产者/消费者加锁，有啥意义？生产消费都得加锁！且加同一把锁（如这个资源）
    理想状态：生产者：有就等待消费，没有就先生产---唤醒消费
             消费者：有就消费，没有就等待生产---唤醒生产
             
             生产一个，消费一个，生产不覆盖，消费不拿重！
             
    事实上：存在先消费，后生产 或者不断生产，可能不断覆盖等问题。
    
    解决方案：Java提供了 等待唤醒机制！
    优化：资源自己实现生产消费，给生产消费线程调用
## 等待唤醒机制----保证生产一次，消费一次，
        Object中
        wait()--等待，让当前线程等待，先立即释放锁--给生产/消费者抢，并在此等待唤醒
        notify()--唤醒单个线程，再一起抢执行权
        notifyAll()--唤醒所有线程
### Why 在Object中？不在Thread中
    生产消费同步情景之下，出现等待和唤醒！锁是资源对象！任意资源对象
    此对象监视器--锁对象
    这些方法的调用必须通过锁对象调用！而刚才使用的对象是任意锁对象！
    故在Object中。
    
### 线程状态转换图
    新建-就绪-运行-死亡
    新建-就绪-运行-就绪-运行-死亡
    新建-就绪-运行-
        其他阻塞sleep()/join()-
        同步阻塞synchronized-
        等待阻塞wait()-（唤醒notify()）-同步阻塞-（锁可用）
            -就绪-运行-死亡
    注意：等待阻塞--同步阻塞的原因？
        Java强制我们的wait()/notify()调用必须要在一个同步块中，
        是因为不想让我们在不经意间出现这种lost wake up问题。
        问题的根源在于，消费者在检查条件到调用wait()之间，生产者调用notify(),
        但这个通知会被丢掉，紧接着，消费者就wait()睡过去了……
             
### 线程组--ThreadGroup
        线程对象.getThreadGroup().getName();---默认属于main线程组
        默认所有线程属于同一个组
    ThreadGroup tg = new ThreadGroup("新组名");   
    new Thread("tg", myRun, "线程名");
    tg.setDaemon(true);// 该组都是守护线程
    tg.setMaxPriority(10);  
        
### 线程池--juc包---Executors工厂类
        与操作系统交互，启动一个线程成本高（招新人成本高），
        使用线程池（资源池）提高功能，尤其需要大量生存期短的线程时。
        JDK5之前手动实现，之后Java内置线程池。
        
##    Executors线程工厂--ExecutorService线程池
        
    Java通过Executors提供四种线程池，分别为：
        1、Cached-缓存的
        public static ExecutorService newCachedThreadPool()
        创建一个可缓存线程池，如果线程池长度超过处理需要，
        可灵活回收空闲线程，若无可回收，则新建线程。
        
        2、Fixed-固定的
        public static ExecutorService newFixedThreadPool(int nThreds) 
        创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
        
        3、Single-单一
        public static ExecutorService newSingleThreadExecutor() 
        创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，
        保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
        
        4、Scheduled-已安排，已预定
        public static ExecutorService newScheduledThreadPool(int nThreds) 
        创建一个定长线程池，支持定时及周期性任务执行。
        
     接口ExecutorService对象可以执行Runnable对象和Callable对象代表的线程。
     并提供了以下的方法：
     Future<?> submit(Runnable task)    
     <T>Future<T> submit(Callable<T> task)    
    注意：
      Executors类生成四个方法的内部实现，
      它们最终调用的都是同一个ThreadPoolExecutor()的构造器，
      而区别在于构造器的参数不同。
    Executors返回线程池对象的弊端！  
        由于OOM问题，全称“Out Of Memory”，“内存用完了” 。
        FixedThreadPool 和 SingleThreadExecutor ： 
        允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。
        CachedThreadPool 和 ScheduledThreadPool ： 
        允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。

## 多线程实现方式3----接口Callable<V>--依赖线程池实现
    特点：
        带泛型的接口---带返回值的线程
        可以抛出异常
    弊端：代码较为复杂
    案例：线程求和！Callable<Integer>
          异步计算的结果接收--接口Future<V>
    


### 匿名内部类
        
# 定时器的使用

# 设计模式
## 简单工厂
## 恶汉单例
## 懒汉单例