#   JDK5
        自动拆装箱
        伪泛型-类型擦除实现
            Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，
            使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。
            原始类型--就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型
            使用泛型机制编写的代码要比哪些杂乱地使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性
            
        增强for---使用iterator-Iterator var18 = arrayList.iterator();
        
        静态导入
        
        可变参数--可变长参数是使用数组存储--数组类型确定，和泛型不能很好的混合使用--用@SafeVarargs解决
        
        枚举--本质就是一个 class，java 编译器帮我们做了语法的解析和编译而已。
            -使用关键字enum来用 一组由常量组成的有限集合 来创建一个新的class类。
            - public enum 枚举类名 反编译后public final class 枚举类名 extends Enum
            
        注解 元数据给Java看的，编译检查，抽取api, 代码分析。--Annotation接口
            预定义==4常
            自定义== 属性 + 4元注解 
                - public @interface 名 反编译后public interface 名 extends java.lang.annotation.Annotation(){}
                接口抽象方法 == 注解属性
                要有返回值（基本类型 + String + 枚举 + 注解 或此等数组）
                定义了属性，使用时就要赋值。可default。若只有value一个属性，使用时键可省。
                自定义注解一般保留RUNTIME，不会去操作编译器
            使用 即 解析注解（获取注解中定义的属性值）
            
            注解 可以代替 配置文件！
            名 c = getAnnotation(名.class); // 多态 // 获取注解对象，其实是在内存中生成了一个该注解接口的子类实现对象。
            
        定义 + 解析-->自定义注解出来了(有难度)--测试框架
        内置注解--编译器使用
        自定义注解--解析程序用--框架
        
        以后多使用而非自定义
           
        注解似是一个标签，非程序一部分，类似配置文件
        无注解不反射! 无框架不注解！    
        
##  枚举--final类
    将变量的值一一列举出来，只限于列举出来的值的范围内。
        有限个数的实例-多例
        
##  自定义枚举类--3版本
        
    简单枚举类--无参构造私有 + 多个实例
    中级枚举类--有参构造私有（成员变量） + 多个实例 + 普通方法
    高级枚举类--抽象类 + 多个匿名内部类实例 + 抽象方法
    
    多例类里有抽象方法--抽象类   
    抽象类不能实例化。怎么解决？
    在抽象类里，匿名内部类实例化
        
##  自定义枚举类--麻烦---Java提供enum--枚举基类Enum实现了toString()
    public enum 枚举类名{
        枚举1，枚举2...;
    }

    通过反编译，查看class文件。
        --类似自定义版本1-2-3.即枚举类--无参，有参，抽象
        --编译器会改造默认和自定义构造器，即无参有参
    
    第一行必须是枚举项，实例系统会自动添加 public static final 修饰
    枚举类的构造器只能使用 private 权限修饰符，但private默认省略，自定义构造器必须private。
    枚举类可有抽象方法，但枚举项必须实现重写。
    枚举在switch中使用
    https://my.oschina.net/u/4382082/blog/4249376/print
    https://www.cnblogs.com/wangyingli/p/5903790.html
    
##  枚举常用方法
    compareTo()
    name()
    ordinal()
    toString()--ReflectionToStringBuilder过滤敏感字符串
    valueOf()
    values()
    
    
#   JDK6新特性很少见    
#   JDK7新特性
    二进制字面量--二进制表示整数--int x = 0b110110;
    数字字面量中间可以出现下划线--增强阅读性，边界别用
    switch语句可以用字符串
    泛型简化
    多个catch合并
    try-with-resource--自动释放资源try(AutoCloseable的子类对象)--JDK的API
    集合（Collections）的增强支持-List<String>list=[“item1”,”item2”];//存
    
#   JDK8新特性    
    允许接口中默认方法-abstract方法-default方法-static方法
    Lambda表达式
        函数式编程思想，输入输出
        
    函数式接口
    内置函数式接口
    Stream和
    Map
    事件日期API
    Annotations
    CompleteFuture
    
    
    
# 语法糖：--便捷写法
    一种便捷的写法，编译器会帮我们做转换；
    而且可以提高开发编码的效率，在性能上也不会带来损失
    反编译后会发现，依然是之前的写法。
    
    增强for即for-each, iterater.hasNext()--增强for循环中不能进行增删改
    
    枚举
        public enum EnumTest {}-->public static final class EnumTest extends Enum<EnumTest>{
    
    try-with-resource ,
    
    注解 
    
    字符串拼接 + -->new StringBuilder().append(s).toString()
    
    条件编译 自动去除false语法
    
    switch只支持整型, 其他诸如String、枚举类型都是转换成整型之后再使用switch的。
    
    可变参数 -String ...str ---->String str[]
        其实就是一个不定长度的数组, 数组长度随传入方法的对应参数个数来决定。可变参数只能在参数列表的末位使用。
    
    自动装箱/拆箱--valueOf()/xxxValue()
    
    内部类--outer$innter.class
        编译过程中, 编译器会自动在内部类定义一个外部类的常量引用this$0, 并且在内部类的构造器中初始化this$0
    
    泛型擦除 遇到重载--List.class--擦除会使两个方法特征签名一摸一样
    
    数值字面量--5_6.3_4--其他进制-->10进制
    
    断言assert--如果断言结果为false，则程序抛出AssertError来打断程序的执行。
    
    lambda表达式--【基本语法：(parameters) -> expression】
    
    JDK10的局部变量类型推断-增强for循环的索引、传统for循环的局部变量
        --var stringList = new ArrayList<String>();
        
    
    Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 
    Iterator被创建之后会建立一个指向原来对象的单链索引表，
    当原来的对象数量发生变化时，这个索引表的内容不会同步改变，
    所以当索引指针往后移动的时候就找不到要迭代的对象，
    所以按照fail-fast原则，Iterator会马上抛出java.util.ConcurrentModificationException异常。
    所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。
    但你可以使用 Iterator 本身的方法remove()来删除对象，
    Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。